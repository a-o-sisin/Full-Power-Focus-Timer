<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow">
    <meta property="og:title" content="ÈõÜ‰∏≠ÔºÜ‰ºëÊÜ©„Çø„Ç§„Éû„Éº">
    <title>ÈõÜ‰∏≠ÔºÜ‰ºëÊÜ©„Çø„Ç§„Éû„Éº</title>
    <style>
        :root {
            --work-color: #4A90E2; /* Work: Blue */
            --break-color: #50E3C2; /* Break: Green */
            --cursor-color: #FF5722; /* Current: Orange */
            --bg-color: #f0f2f5;
            --text-color: #333;
        }

        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh; 
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.5s;
        }

        /* Settings Area */
        .settings {
            display: flex;
            gap: 20px;
            margin-bottom: 10px;
            background: white;
            padding: 15px 25px;
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }

        .input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        label {
            font-size: 0.8rem;
            font-weight: bold;
            color: #666;
            margin-bottom: 5px;
        }

        input[type="number"] {
            width: 50px;
            padding: 5px;
            text-align: center;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
        }

        /* Main Timer Display */
        .timer-wrapper {
            position: relative;
            width: 300px;
            height: 300px;
            margin: 20px 0;
        }

        svg {
            transform: rotate(-90deg);
            width: 100%;
            height: 100%;
        }

        circle {
            fill: none;
            stroke-width: 20;
            transition: stroke-dasharray 0.5s;
        }

        /* Background */
        .base-circle { stroke: #e6e6e6; }
        /* Work Arc */
        .work-arc { stroke: var(--work-color); }
        /* Break Arc */
        .break-arc { stroke: var(--break-color); }

        /* Cursor Pointer */
        .cursor-point {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            transition: transform 0.1s linear;
        }
        
        .cursor-point::after {
            content: '';
            position: absolute;
            top: 10px; 
            left: 50%;
            width: 16px; height: 16px;
            background-color: #fff;
            border: 4px solid var(--cursor-color);
            border-radius: 50%;
            transform: translateX(-50%);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* Center Text Info */
        .info-display {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            width: 80%;
        }

        .main-time {
            font-size: 3rem;
            font-weight: bold;
            display: block;
            line-height: 1.2;
            color: #333;
        }

        .sub-message {
            display: block;
            margin-top: 10px;
            font-size: 0.9rem;
            color: #666;
            min-height: 1.5em;
        }

        .praise-message {
            color: #E91E63;
            font-weight: bold;
            font-size: 1.1rem;
            animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Control Buttons */
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
        }

        button {
            padding: 12px 30px;
            font-size: 1rem;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        #startBtn { background-color: var(--work-color); color: white; }
        #startBtn:hover { background-color: #357ABD; transform: translateY(-2px); }
        #resetBtn { background-color: #fff; color: #666; border: 1px solid #ddd; }
        #resetBtn:hover { background-color: #f8f8f8; }

        /* Daily Stats Area */
        .daily-stats {
            background: #fff;
            padding: 15px 20px;
            border-radius: 12px;
            width: 85%;
            max-width: 320px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            text-align: center;
        }

        .stats-title {
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 8px;
            display: block;
            font-weight: bold;
        }

        .stats-content {
            display: flex;
            justify-content: space-around;
            align-items: center;
            font-size: 1rem;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label {
            font-size: 0.75rem;
            color: #aaa;
        }

        .stat-value {
            font-weight: bold;
            font-size: 1.2rem;
            margin-top: 2px;
        }
        
        .work-stat { color: var(--work-color); }
        .break-stat { color: var(--break-color); }

    </style>
</head>
<body>

    <div class="settings">
        <div class="input-group">
            <label>‰ΩúÊ•≠(ÂàÜ)</label>
            <input type="number" id="workInput" value="50" min="1">
        </div>
        <div class="input-group">
            <label>‰ºëÊÜ©(ÂàÜ)</label>
            <input type="number" id="breakInput" value="10" min="1">
        </div>
    </div>

    <div class="timer-wrapper">
        <svg viewBox="0 0 320 320">
            <circle class="base-circle" cx="160" cy="160" r="140"></circle>
            <circle class="work-arc" cx="160" cy="160" r="140"></circle>
            <circle class="break-arc" cx="160" cy="160" r="140"></circle>
        </svg>
        
        <div class="cursor-point" id="cursorPoint"></div>

        <div class="info-display">
            <span class="sub-message" id="topMsg">Ê∫ñÂÇôÂÆå‰∫Ü</span>
            <span class="main-time" id="timeDisplay">--:--</span>
            <span class="sub-message" id="btmMsg">„Çπ„Çø„Éº„Éà„Éú„Çø„É≥„ÇíÊäº„Åó„Å¶„Å≠</span>
        </div>
    </div>

    <div class="controls">
        <button id="startBtn">„Çπ„Çø„Éº„Éà</button>
        <button id="resetBtn">„É™„Çª„ÉÉ„Éà</button>
    </div>

    <div class="daily-stats">
        <span class="stats-title" id="statsDate">--Êúà--Êó•„ÅÆÂÆüÁ∏æ</span>
        <div class="stats-content">
            <div class="stat-item">
                <span class="stat-label">‰ΩúÊ•≠</span>
                <span class="stat-value work-stat" id="totalWorkTime">0ÂàÜ</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">‰ºëÊÜ©</span>
                <span class="stat-value break-stat" id="totalBreakTime">0ÂàÜ</span>
            </div>
        </div>
    </div>

    <script>
        // --- Settings & Constants ---
        const RADIUS = 140;
        const CIRCUMFERENCE = 2 * Math.PI * RADIUS;
        const workInput = document.getElementById('workInput');
        const breakInput = document.getElementById('breakInput');
        
        // --- Elements ---
        const workArc = document.querySelector('.work-arc');
        const breakArc = document.querySelector('.break-arc');
        const cursorPoint = document.getElementById('cursorPoint');
        const timeDisplay = document.getElementById('timeDisplay');
        const topMsg = document.getElementById('topMsg');
        const btmMsg = document.getElementById('btmMsg');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');
        
        // Stats Elements
        const statsDate = document.getElementById('statsDate');
        const totalWorkElem = document.getElementById('totalWorkTime');
        const totalBreakElem = document.getElementById('totalBreakTime');

        // --- State Management ---
        let totalCycleSeconds = 0;
        let workSeconds = 0;
        let breakSeconds = 0;
        
        let startTime = 0;    
        let pausedTime = 0;   
        let timerInterval = null;
        let isRunning = false;
        
        let lastTickSec = 0;
        
        // Daily Stats
        let dailyWorkSec = 0;
        let dailyBreakSec = 0;
        let todayStr = ""; // YYYY-MM-DD

        let audioCtx = null;
        let wakeLock = null;

        const praiseMessages = [
            "Â§©ÊâçÁöÑ„Å™ÈõÜ‰∏≠Âäõ„Åß„Åó„ÅüÔºÅ", "Á¥†Êô¥„Çâ„Åó„ÅÑÔºÅ„ÇÜ„Å£„Åè„Çä‰ºë„Çì„ÅßÔºÅ",
            "„Åù„ÅÆË™øÂ≠êÔºÅ„ÅÇ„Å™„Åü„ÅØÊúÄÈ´ò„Åß„ÅôÔºÅ", "ÂÆåÁíß„Å™‰ªï‰∫ã„Å∂„Çä„Åß„ÅôÔºÅ",
            "„Åô„Åî„ÅÑÔºÅÁõÆÊ®ôÈÅîÊàê„Åä„ÇÅ„Åß„Å®„ÅÜÔºÅ", "Á•û„Åå„Åã„Å£„ÅüÈõÜ‰∏≠ÂäõÔºÅ"
        ];

        // --- Initialization ---
        function initTimer() {
            const wMin = parseInt(workInput.value);
            const bMin = parseInt(breakInput.value);
            workSeconds = wMin * 60;
            breakSeconds = bMin * 60;
            totalCycleSeconds = workSeconds + breakSeconds;

            // Draw Circle
            const workRatio = workSeconds / totalCycleSeconds;
            const workDash = workRatio * CIRCUMFERENCE;
            workArc.style.strokeDasharray = `${workDash} ${CIRCUMFERENCE}`;
            workArc.style.strokeDashoffset = 0;

            const breakRatio = breakSeconds / totalCycleSeconds;
            const breakDash = breakRatio * CIRCUMFERENCE;
            breakArc.style.strokeDasharray = `${breakDash} ${CIRCUMFERENCE}`;
            breakArc.style.strokeDashoffset = -workDash;

            updateVisuals(0);
        }

        // --- Stats Logic ---
        function loadDailyStats() {
            try {
                const now = new Date();
                const year = now.getFullYear();
                const month = now.getMonth() + 1;
                const day = now.getDate();
                todayStr = `${year}-${month}-${day}`; 

                statsDate.textContent = `üìÖ ${month}Êúà${day}Êó•„ÅÆÂÆüÁ∏æ`;

                const savedData = localStorage.getItem(`timer_stats_${todayStr}`);
                if (savedData) {
                    const parsed = JSON.parse(savedData);
                    dailyWorkSec = parsed.work || 0;
                    dailyBreakSec = parsed.break || 0;
                } else {
                    dailyWorkSec = 0;
                    dailyBreakSec = 0;
                }
                updateStatsDisplay();
            } catch (e) {
                console.error("Storage load failed", e);
            }
        }

        function saveDailyStats() {
            try {
                const data = {
                    work: dailyWorkSec,
                    break: dailyBreakSec
                };
                localStorage.setItem(`timer_stats_${todayStr}`, JSON.stringify(data));
            } catch (e) {
                // If saving fails (e.g., Private Mode), just ignore it.
                // This prevents the "Infinite Loop" crash.
                console.warn("Storage save failed", e);
            }
        }

        function updateStatsDisplay() {
            totalWorkElem.textContent = `${Math.floor(dailyWorkSec / 60)}ÂàÜ`;
            totalBreakElem.textContent = `${Math.floor(dailyBreakSec / 60)}ÂàÜ`;
        }

        // --- Accumulation Logic ---
        function accumulateTime(prevSec, currSec) {
            if (currSec <= prevSec) return;

            // Cap calculation at cycle end to prevent "Infinite Break"
            const safeCurr = Math.min(currSec, totalCycleSeconds);
            const start = prevSec;
            const end = safeCurr;
            
            // If already at end, do nothing
            if (start >= end) return;

            // 1. Work Time Addition
            const workOverlapStart = Math.max(start, 0);
            const workOverlapEnd = Math.min(end, workSeconds);
            if (workOverlapEnd > workOverlapStart) {
                dailyWorkSec += (workOverlapEnd - workOverlapStart);
            }

            // 2. Break Time Addition
            const breakOverlapStart = Math.max(start, workSeconds);
            const breakOverlapEnd = Math.min(end, totalCycleSeconds);
            if (breakOverlapEnd > breakOverlapStart) {
                dailyBreakSec += (breakOverlapEnd - breakOverlapStart);
            }
            
            saveDailyStats(); // Protected by try-catch
            updateStatsDisplay();
        }

        // --- Visual Updates ---
        function updateVisuals(currentSec) {
            if (currentSec > totalCycleSeconds) currentSec = totalCycleSeconds;

            let isWorkPhase = currentSec < workSeconds;
            let displayTimeSeconds = 0;

            if (isWorkPhase) {
                displayTimeSeconds = workSeconds - currentSec;
                timeDisplay.style.color = "#333";
                if(isRunning) {
                    topMsg.textContent = "‰ΩúÊ•≠‰∏≠";
                    btmMsg.textContent = `„ÅÇ„Å®${Math.ceil(displayTimeSeconds/60)}ÂàÜÔºÅÈ†ëÂºµ„Çç„ÅÜÔºÅ`;
                    btmMsg.className = "sub-message";
                }
            } else {
                displayTimeSeconds = totalCycleSeconds - currentSec;
                timeDisplay.style.color = "var(--break-color)";
                if(isRunning) {
                    topMsg.textContent = "‰ºëÊÜ©‰∏≠";
                    if (!btmMsg.classList.contains('praise-message')) {
                         btmMsg.textContent = "„É™„É©„ÉÉ„ÇØ„Çπ„Åó„Å¶„Å≠";
                    }
                }
            }

            const m = Math.floor(displayTimeSeconds / 60).toString().padStart(2, '0');
            const s = (displayTimeSeconds % 60).toString().padStart(2, '0');
            timeDisplay.textContent = `${m}:${s}`;

            const progressRatio = currentSec / totalCycleSeconds;
            const degrees = progressRatio * 360;
            cursorPoint.style.transform = `rotate(${degrees}deg)`;
        }

        // --- Audio (Beep) ---
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playBeep(type) {
            if (!audioCtx) return;
            try {
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);

                if (type === 'short') {
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(880, audioCtx.currentTime);
                    gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.1);
                } else if (type === 'long') {
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(880, audioCtx.currentTime);
                    oscillator.frequency.setValueAtTime(1760, audioCtx.currentTime + 0.1);
                    oscillator.frequency.setValueAtTime(880, audioCtx.currentTime + 0.2);
                    oscillator.frequency.setValueAtTime(1760, audioCtx.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.5);
                }
            } catch(e) {
                console.error("Audio error", e);
            }
        }

        // --- Screen Wake Lock ---
        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                }
            } catch (err) {
                console.error(`${err.name}, ${err.message}`);
            }
        }

        function releaseWakeLock() {
            if (wakeLock !== null) {
                wakeLock.release()
                    .then(() => {
                        wakeLock = null;
                    });
            }
        }

        // --- Main Loop ---
        function tick() {
            try {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                let currentSec = elapsed; 

                // If cycle complete
                if (currentSec > totalCycleSeconds) {
                    accumulateTime(lastTickSec, totalCycleSeconds);
                    finishCycle();
                    return;
                }

                // Add time
                accumulateTime(lastTickSec, currentSec);

                // Beep Logic
                if (lastTickSec < workSeconds && currentSec >= workSeconds) {
                    playBeep('long');
                    showPraise();
                }
                else if (currentSec < workSeconds) {
                    const step = Math.floor(workSeconds * 0.2);
                    const prevStepCount = Math.floor(lastTickSec / step);
                    const currStepCount = Math.floor(currentSec / step);
                    
                    if (currStepCount > prevStepCount && lastTickSec > 0) {
                         playBeep('short');
                    }
                }

                // Update lastTickSec *AFTER* safe execution
                lastTickSec = currentSec;
                updateVisuals(currentSec);

            } catch (e) {
                console.error("Tick error", e);
                // Emergency recovery: force update lastTickSec so we don't double count
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                lastTickSec = elapsed;
            }
        }

        function showPraise() {
            const randomMsg = praiseMessages[Math.floor(Math.random() * praiseMessages.length)];
            btmMsg.textContent = randomMsg;
            btmMsg.className = "sub-message praise-message";
        }

        function finishCycle() {
            playBeep('long');
            clearInterval(timerInterval);
            isRunning = false;
            releaseWakeLock(); 
            startBtn.textContent = "„Çπ„Çø„Éº„Éà";
            alert("1„Çµ„Ç§„ÇØ„É´ÁµÇ‰∫Ü„Åß„ÅôÔºÅ„ÅäÁñ≤„ÇåÊßò„Åß„Åó„Åü„ÄÇ");
            pausedTime = 0;
            btmMsg.className = "sub-message";
            btmMsg.textContent = "„ÇÇ„ÅÜ‰∏ÄÂ∫¶È†ëÂºµ„ÇãÔºü";
            updateVisuals(0);
        }

        // --- Events ---
        startBtn.addEventListener('click', () => {
            initAudio();
            
            if (isRunning) {
                // Pause
                clearInterval(timerInterval);
                isRunning = false;
                releaseWakeLock(); 
                pausedTime = Math.floor((Date.now() - startTime) / 1000);
                startBtn.textContent = "ÂÜçÈñã";
            } else {
                // Start
                requestWakeLock(); 
                loadDailyStats();

                if (pausedTime === 0) {
                    initTimer(); 
                    startTime = Date.now();
                    lastTickSec = 0; 
                } else {
                    // Resume
                    startTime = Date.now() - (pausedTime * 1000);
                    lastTickSec = pausedTime; 
                }
                
                isRunning = true;
                startBtn.textContent = "‰∏ÄÊôÇÂÅúÊ≠¢";
                
                const currentSec = pausedTime;
                topMsg.textContent = currentSec < workSeconds ? "‰ΩúÊ•≠‰∏≠" : "‰ºëÊÜ©‰∏≠";

                timerInterval = setInterval(tick, 200); 
            }
        });

        resetBtn.addEventListener('click', () => {
            clearInterval(timerInterval);
            isRunning = false;
            releaseWakeLock(); 
            pausedTime = 0;
            lastTickSec = 0;
            startBtn.textContent = "„Çπ„Çø„Éº„Éà";
            topMsg.textContent = "Ê∫ñÂÇôÂÆå‰∫Ü";
            btmMsg.textContent = "„Çπ„Çø„Éº„Éà„Éú„Çø„É≥„ÇíÊäº„Åó„Å¶„Å≠";
            btmMsg.className = "sub-message";
            initTimer();
        });

        [workInput, breakInput].forEach(input => {
            input.addEventListener('change', () => {
                if (!isRunning) {
                    pausedTime = 0;
                    initTimer();
                }
            });
        });

        // Init
        initTimer();
        loadDailyStats();
        
        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') {
                await requestWakeLock();
            }
        });

    </script>
</body>
</html>
