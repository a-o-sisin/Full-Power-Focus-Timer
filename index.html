<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="robots" content="noindex, nofollow">

    <meta property="og:title" content="集中＆休憩タイマー">
    <meta property="og:description" content="作業時間と休憩時間を自由に設定できる、視覚的にわかりやすい円グラフタイマーです。">
    <meta property="og:type" content="website">

    <title>集中＆休憩タイマー</title>
    <style>
        :root {
            --work-color: #4A90E2; /* 作業：青 */
            --break-color: #50E3C2; /* 休憩：緑 */
            --cursor-color: #FF5722; /* 現在地：オレンジ */
            --bg-color: #f0f2f5;
            --text-color: #333;
        }

        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.5s;
        }

        /* 設定エリア */
        .settings {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            background: white;
            padding: 15px 25px;
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }

        .input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        label {
            font-size: 0.8rem;
            font-weight: bold;
            color: #666;
            margin-bottom: 5px;
        }

        input[type="number"] {
            width: 50px;
            padding: 5px;
            text-align: center;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
        }

        /* メインタイマー表示部 */
        .timer-wrapper {
            position: relative;
            width: 320px;
            height: 320px;
            margin: 20px 0;
        }

        svg {
            transform: rotate(-90deg);
            width: 100%;
            height: 100%;
        }

        circle {
            fill: none;
            stroke-width: 20;
            transition: stroke-dasharray 0.5s;
        }

        /* 背景用 */
        .base-circle { stroke: #e6e6e6; }
        /* 作業時間のアーク */
        .work-arc { stroke: var(--work-color); }
        /* 休憩時間のアーク */
        .break-arc { stroke: var(--break-color); }

        /* 現在位置を示すポインター */
        .cursor-point {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            transition: transform 0.1s linear; /* 動きをスムーズに */
        }
        
        .cursor-point::after {
            content: '';
            position: absolute;
            top: 10px; /* 半径に合わせて調整 */
            left: 50%;
            width: 16px; height: 16px;
            background-color: #fff;
            border: 4px solid var(--cursor-color);
            border-radius: 50%;
            transform: translateX(-50%);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* 中央のテキスト情報 */
        .info-display {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            width: 80%;
        }

        .main-time {
            font-size: 3rem;
            font-weight: bold;
            display: block;
            line-height: 1.2;
            color: #333;
        }

        .sub-message {
            display: block;
            margin-top: 10px;
            font-size: 1rem;
            color: #666;
            min-height: 1.5em;
        }

        .praise-message {
            color: #E91E63;
            font-weight: bold;
            font-size: 1.1rem;
            animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* コントロールボタン */
        .controls {
            display: flex;
            gap: 15px;
        }

        button {
            padding: 12px 30px;
            font-size: 1rem;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        #startBtn { background-color: var(--work-color); color: white; }
        #startBtn:hover { background-color: #357ABD; transform: translateY(-2px); }
        #resetBtn { background-color: #fff; color: #666; border: 1px solid #ddd; }
        #resetBtn:hover { background-color: #f8f8f8; }

    </style>
</head>
<body>

    <div class="settings">
        <div class="input-group">
            <label>作業(分)</label>
            <input type="number" id="workInput" value="50" min="1">
        </div>
        <div class="input-group">
            <label>休憩(分)</label>
            <input type="number" id="breakInput" value="10" min="1">
        </div>
    </div>

    <div class="timer-wrapper">
        <svg viewBox="0 0 320 320">
            <circle class="base-circle" cx="160" cy="160" r="140"></circle>
            <circle class="work-arc" cx="160" cy="160" r="140"></circle>
            <circle class="break-arc" cx="160" cy="160" r="140"></circle>
        </svg>
        
        <div class="cursor-point" id="cursorPoint"></div>

        <div class="info-display">
            <span class="sub-message" id="topMsg">準備完了</span>
            <span class="main-time" id="timeDisplay">--:--</span>
            <span class="sub-message" id="btmMsg">スタートボタンを押してね</span>
        </div>
    </div>

    <div class="controls">
        <button id="startBtn">スタート</button>
        <button id="resetBtn">リセット</button>
    </div>

    <script>
        // --- 設定と定数 ---
        const RADIUS = 140;
        const CIRCUMFERENCE = 2 * Math.PI * RADIUS;
        const workInput = document.getElementById('workInput');
        const breakInput = document.getElementById('breakInput');
        
        // --- 要素の取得 ---
        const workArc = document.querySelector('.work-arc');
        const breakArc = document.querySelector('.break-arc');
        const cursorPoint = document.getElementById('cursorPoint');
        const timeDisplay = document.getElementById('timeDisplay');
        const topMsg = document.getElementById('topMsg');
        const btmMsg = document.getElementById('btmMsg');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');

        // --- 状態管理 ---
        let totalCycleSeconds = 0;
        let workSeconds = 0;
        let breakSeconds = 0;
        
        // 【修正点1】経過時間を管理するための変数を変更
        let startTime = 0;    // タイマー開始時のタイムスタンプ
        let pausedTime = 0;   // 一時停止した時点での経過時間
        let timerInterval = null;
        let isRunning = false;
        
        let audioCtx = null;
        let wakeLock = null; // 【修正点2】Wake Lock用変数

        const praiseMessages = [
            "天才的な集中力でした！", "素晴らしい！ゆっくり休んで！",
            "その調子！あなたは最高です！", "完璧な仕事ぶりです！",
            "すごい！目標達成おめでとう！", "神がかった集中力！"
        ];

        // --- 初期化 ---
        function initTimer() {
            const wMin = parseInt(workInput.value);
            const bMin = parseInt(breakInput.value);
            workSeconds = wMin * 60;
            breakSeconds = bMin * 60;
            totalCycleSeconds = workSeconds + breakSeconds;

            // 円グラフ描画
            const workRatio = workSeconds / totalCycleSeconds;
            const workDash = workRatio * CIRCUMFERENCE;
            workArc.style.strokeDasharray = `${workDash} ${CIRCUMFERENCE}`;
            workArc.style.strokeDashoffset = 0;

            const breakRatio = breakSeconds / totalCycleSeconds;
            const breakDash = breakRatio * CIRCUMFERENCE;
            breakArc.style.strokeDasharray = `${breakDash} ${CIRCUMFERENCE}`;
            breakArc.style.strokeDashoffset = -workDash;

            updateVisuals(0); // 0秒地点で描画
        }

        // --- 表示更新 ---
        function updateVisuals(currentSec) {
            // 安全策：時間を超過しないように丸める
            if (currentSec > totalCycleSeconds) currentSec = totalCycleSeconds;

            let isWorkPhase = currentSec < workSeconds;
            let displayTimeSeconds = 0;

            if (isWorkPhase) {
                displayTimeSeconds = workSeconds - currentSec;
                timeDisplay.style.color = "#333";
                if(isRunning) {
                    topMsg.textContent = "作業中";
                    btmMsg.textContent = `あと${Math.ceil(displayTimeSeconds/60)}分！頑張ろう！`;
                    btmMsg.className = "sub-message";
                }
            } else {
                displayTimeSeconds = totalCycleSeconds - currentSec;
                timeDisplay.style.color = "var(--break-color)";
                if(isRunning) {
                    topMsg.textContent = "休憩中";
                    if (!btmMsg.classList.contains('praise-message')) {
                         btmMsg.textContent = "リラックスしてね";
                    }
                }
            }

            const m = Math.floor(displayTimeSeconds / 60).toString().padStart(2, '0');
            const s = (displayTimeSeconds % 60).toString().padStart(2, '0');
            timeDisplay.textContent = `${m}:${s}`;

            const progressRatio = currentSec / totalCycleSeconds;
            const degrees = progressRatio * 360;
            cursorPoint.style.transform = `rotate(${degrees}deg)`;
        }

        // --- 音声 (Beep) ---
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playBeep(type) {
            if (!audioCtx) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            if (type === 'short') {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(880, audioCtx.currentTime);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'long') {
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(880, audioCtx.currentTime);
                oscillator.frequency.setValueAtTime(1760, audioCtx.currentTime + 0.1);
                oscillator.frequency.setValueAtTime(880, audioCtx.currentTime + 0.2);
                oscillator.frequency.setValueAtTime(1760, audioCtx.currentTime + 0.3);
                gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.5);
            }
        }

        // --- 【修正点3】Screen Wake Lock (画面常時オン) ---
        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Wake Lock is active');
                }
            } catch (err) {
                console.error(`${err.name}, ${err.message}`);
            }
        }

        function releaseWakeLock() {
            if (wakeLock !== null) {
                wakeLock.release()
                    .then(() => {
                        wakeLock = null;
                        console.log('Wake Lock released');
                    });
            }
        }

        // --- 進行ロジック ---
        function tick() {
            // 現在時刻と開始時刻の差分から正確な経過時間を算出
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            
            // 実際に表示すべき秒数 (一時停止していた分があれば足す... 今回はリセット型なのでシンプルに)
            // ここでは pause機能を「一時停止」として実装する場合のロジックを入れています
            let currentSec = elapsed; 

            if (currentSec > totalCycleSeconds) {
                finishCycle();
                return;
            }

            // 音のタイミング制御（厳密な一致が難しいため、変化した瞬間を検知するロジックに変更）
            // ※簡易的に、前回の秒数と比較する方法もありますが、
            // 今回は「特定の秒数を通過したか」を判定するのは複雑になるため、
            // 表示更新に合わせて特定のタイミングで鳴らす簡易実装のままにします。
            // ただし、厳密なタイミングで鳴らしたい場合は、次の秒数に切り替わった瞬間を検知する必要があります。
            
            // 簡易実装: 秒が変わったタイミングで判定 (Date.nowベースだと毎フレーム呼ぶわけではないので、
            // setIntervalの精度依存にはなりますが、時間はズレません)
            
            // 作業終了（休憩開始）の判定
            if (currentSec === workSeconds && workSeconds > 0) {
                 // 連続再生を防ぐフラグ管理が必要ですが、簡易的に音を鳴らします
                 // 厳密には「直前のtickでworkSeconds未満だった」判定が必要ですが、
                 // 1秒ごとの更新ならほぼ大丈夫です。
                 // 念のため、音が鳴りまくらないようにするのはUI側で制御
            }

            // ここではシンプルに描画更新に専念させ、
            // 特定時刻のイベント（音）は「前回の秒数」を覚えておいて「またいだら鳴らす」がベストですが
            // 既存ロジックを極力活かして実装します。
            
            // 既存ロジックの「特定秒数での音」を再現するための工夫
            // currentSecが変化したタイミングでのみ処理を行う
            if (this.lastSec !== currentSec) {
                if (currentSec === workSeconds) {
                    playBeep('long');
                    showPraise();
                } else if (currentSec === totalCycleSeconds) {
                     playBeep('long');
                } else if (currentSec < workSeconds) {
                    const step = Math.floor(workSeconds * 0.2);
                    if (currentSec % step === 0 && currentSec > 0) playBeep('short');
                }
                this.lastSec = currentSec;
            }

            updateVisuals(currentSec);
        }

        function showPraise() {
            const randomMsg = praiseMessages[Math.floor(Math.random() * praiseMessages.length)];
            btmMsg.textContent = randomMsg;
            btmMsg.className = "sub-message praise-message";
        }

        function finishCycle() {
            clearInterval(timerInterval);
            isRunning = false;
            releaseWakeLock(); // 終了時に画面ロック解除
            startBtn.textContent = "スタート";
            alert("1サイクル終了です！お疲れ様でした。");
            pausedTime = 0;
            btmMsg.className = "sub-message";
            btmMsg.textContent = "もう一度頑張る？";
            updateVisuals(0);
        }

        // --- イベント ---
        startBtn.addEventListener('click', () => {
            initAudio();
            
            if (isRunning) {
                // 一時停止処理
                clearInterval(timerInterval);
                isRunning = false;
                releaseWakeLock(); // 一時停止時は画面オフ許可
                
                // 停止した時点での経過時間を保存
                pausedTime = Math.floor((Date.now() - startTime) / 1000);
                startBtn.textContent = "再開";
                
            } else {
                // 開始処理
                requestWakeLock(); // 画面常時オン要求
                
                if (pausedTime === 0) {
                    initTimer(); // 最初から
                    startTime = Date.now();
                } else {
                    // 再開時：現在時刻から「すでに経過した時間」を引いた時間を開始時間とみなす
                    startTime = Date.now() - (pausedTime * 1000);
                }
                
                isRunning = true;
                startBtn.textContent = "一時停止";
                
                // 初回描画
                const currentSec = pausedTime;
                topMsg.textContent = currentSec < workSeconds ? "作業中" : "休憩中";

                // インターバル開始
                timerInterval = setInterval(tick, 200); // 描画をスムーズにするため更新頻度アップ
            }
        });

        resetBtn.addEventListener('click', () => {
            clearInterval(timerInterval);
            isRunning = false;
            releaseWakeLock(); // リセット時も画面オフ許可
            pausedTime = 0;
            startBtn.textContent = "スタート";
            topMsg.textContent = "準備完了";
            btmMsg.textContent = "スタートボタンを押してね";
            btmMsg.className = "sub-message";
            initTimer();
        });

        [workInput, breakInput].forEach(input => {
            input.addEventListener('change', () => {
                if (!isRunning) {
                    pausedTime = 0;
                    initTimer();
                }
            });
        });

        initTimer();
        
        // ページを離れたり戻ったりした時のWake Lock再取得
        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') {
                await requestWakeLock();
            }
        });

    </script>
</body>
</html>
